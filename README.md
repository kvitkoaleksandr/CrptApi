# CrptApi — реализация тестового задания

## Что реализовано

В этом проекте реализован класс `CrptApi`, который представляет собой потокобезопасный клиент для отправки документов через HTTP API. Цель — создать удобный, расширяемый и аккуратно организованный код, без излишней сложности, но с опорой на принципы чистой архитектуры.

Основной класс `CrptApi` содержит:

- Метод `createDocument(...)`, который сериализует объект документа, формирует HTTP-запрос и отправляет его на сервер;
- Встроенную реализацию **RateLimiter** на стандартных средствах Java (без сторонних библиотек);
- Использование `HttpClient` из JDK 11 и `ObjectMapper` из Jackson для сериализации JSON;
- Вложенные классы `Document` (с билдером) и `CreateDocumentRequest` — для чистой модели запроса.

---

## Почему реализовано несколько конструкторов

- **Основной конструктор** используется в приложении — он задаёт базовый `apiUrl` и создаёт стандартный `HttpClient`;
- **Второй конструктор** позволяет подменить `apiUrl` — удобно для тестирования или переключения между окружениями;
- **Третий конструктор** — тестовый, принимает мок `HttpClient`. Он добавлен по принципу *Dependency Injection*, чтобы было удобно писать unit-тесты с Mockito, без изменения логики боевого кода.

---

## Тестирование

В проекте реализован класс `CrptApiTest`, который покрывает:

  + Успешный сценарий вызова метода `createDocument(...)` и отправки запроса;
  - Ошибочный путь: сервер возвращает 500 — выбрасывается `IOException`.

Тесты написаны с использованием **JUnit 5 + Mockito**, без избыточной конфигурации.  
Структура тестов соответствует хорошей практике:
- AAA-подход (Arrange → Act → Assert);
- точное мокирование зависимостей;
- читаемые и выразительные названия методов.

---

## Как можно улучшить (если бы условия позволяли)

Если бы задание разрешало использовать сторонние библиотеки и расширять архитектуру, проект можно было бы усилить следующими улучшениями:

### Интеграционные тесты через Docker/Testcontainers

- Поднять локальный HTTP-сервер (например, WireMock или MockServer в контейнере);
- Проверять реальные HTTP-запросы и сериализацию JSON;
- Проверять заголовки, тело, `RateLimiter` в боевых условиях;
- Такой подход применим в микросервисной архитектуре и при интеграции с API.

---

### Разделение на слои и интерфейсы

- Выделить интерфейс `ApiClient` и реализацию `CrptApi` — для облегчения тестирования по контракту;
- Вынести `RateLimiter` в отдельный переиспользуемый компонент;
- Разделить обязанности на:
  - `RequestBuilder` (сборка запроса),
  - `RequestSender` (отправка),
  - `RequestSerializer` (сериализация) — это улучшит поддержку и читаемость.

---

### Логирование и мониторинг

- Добавить логирование через `java.util.logging` или `SLF4J`;
- Логировать отправку, ошибки, поведение лимитера;
- Возможность отключать/включать лог через конфигурацию;
- Это критично важно при отладке в проде или при мониторинге системной активности.

---
